<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Learning Programming <br> & <br> Stuff]]></title>
  <link href="http://kylefdoherty.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://kylefdoherty.github.io/"/>
  <updated>2014-06-11T12:41:55-04:00</updated>
  <id>http://kylefdoherty.github.io/</id>
  <author>
    <name><![CDATA[Kyle Doherty]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Notes - Structs]]></title>
    <link href="http://kylefdoherty.github.io/blog/2014/03/07/structs/"/>
    <updated>2014-03-07T10:11:19-05:00</updated>
    <id>http://kylefdoherty.github.io/blog/2014/03/07/structs</id>
    <content type="html"><![CDATA[<p>I recently learned about Structs while working my way through <a href="http://pragmaticstudio.com/courses" target="_blank">Pragmatic Studio’s Ruby Programming course</a>, which I highly recommend btw.  If you’re a beginner like me it will apply your basic Ruby knowledge to a project and teach you some new things along the way&hellip;like Structs.</p>

<h2>What Are Structs</h2>


<p>Structs are simply a collection of attributes, meaning they only have state, whereas Classes have both attributes and methods (state and behavior).  To illustrate imagine we have a library class containing a bunch of book objects (its state) that you can check out and do other things to (its behavior). This type of object, since it has state and behavior warrants using a class.</p>

<p>``` ruby Library Class
class Library
  def initialize</p>

<pre><code>@books = []
</code></pre>

<p>  end</p>

<p>  def checkout</p>

<pre><code># code to checkout a book
</code></pre>

<p>  end
end<br/>
```
Now, let’s assume the book objects the library class will contain won’t have any behavior i.e. they won’t have methods, they’ll simply have attributes such as: <code>@title</code>, <code>@author</code>, and <code>@page_number</code>.  We could create a book class like this:</p>

<p>```ruby Book Class
class Book
  attr_reader :title, :author, :page_number</p>

<p>  def initialize(title, author, page_number)</p>

<pre><code>@title = title
@author = author
@page_number = page_number
</code></pre>

<p>  end
end
```
OR since the book object has no methods we can use a Struct like so:</p>

<p>```ruby Book Struct
Book = Struct.new(:title, :author, :page_number)</p>

<h1>=> Book</h1>

<p>Book.class</p>

<h1>=> Class</h1>

<p>```
Using a Struct required far less code than writing out the book class ourselves and by calling <code>.class</code> on Book we can see that <code>Struct.new</code> actually went and generated the book class we made above for us&hellip;pretty cool huh!</p>

<h2>Create Object Instances</h2>


<p>With this Book class we can create as many new book objects as we want by calling <code>Book.new</code> and passing it a title, author, and number of pages, like below:</p>

<p>```ruby
book1 = Book.new(“Learn to Program”, “Chris Pine”, 171)</p>

<h1>=> <struct Book title="Learn to Program", author="Chris Pine", page_number=171></h1>

<p>book2 = Book.new(“The Well Grounded Rubyist”, “David A. Black”, 500)</p>

<h1>=> <struct Book title="The Well Grounded Rubyist", author="David A. Black", page_number=500></h1>

<p>book3 = Book.new(“Programming Ruby 1.9 &amp; 2.0: The Pragmatic Programmers Guide (The Facets of Ruby)”, “Dave Thomas, Andy Hunt, Chris Fowler”, 888)</p>

<h1>=> <struct Book title="Programming Ruby 1.9 & 2.0: The Pragmatic Programmers' Guide (The Facets of Ruby)", author="Dave Thomas, Andy Hunt, Chris Fowler", page_number=888></h1>

<p>```
This code instantiated 3 new book objects each with readable and writable attributes.  One interesting thing about these book objects is they are actually Struct objects and therefore have some handy struct methods for accessing their attributes.</p>

<h2>Accessing Attributes</h2>


<p>In addition to the normal way of accessing class attributes you can also use the <code>[]</code> method to access attributes like you would from an array by inserting the index in the brackets or like you from a hash by inserting the key in the brackets.  Here are some examples:</p>

<p>```ruby Accessing Struct Attributes
book1[0]</p>

<h1>=> “Learn to Program”</h1>

<p>book1[“title”]</p>

<h1>=> “Learn to Program”</h1>

<p>book1[:title]</p>

<h1>=> “Learn to Program”</h1>

<p>```</p>

<p>As you can see you can access the <code>title</code> attribute by index or by name using a String or Symbol.</p>

<h2>Learn More About Structs</h2>




<ul>
  <li>You can see more Struct methods by checking out the <a href="http://ruby-doc.org/core-1.9.3/Struct.html" target="_blank">Struct Class doc</a>.</li>

  <li>For a more comprehensive explination of Structs read the blog post <a href="http://blog.rubybestpractices.com/posts/rklemme/017-Struct.html" target="_blank">Structs Inside and Out</a></li>

  <li>If you want to make Read-only Structs check out the <a href="https://github.com/janlelis/value_struct" target="_blank">Value Struct Gem</a> and this <a href="http://ruby.janlelis.de/65-value_struct-read-only-structs-in-ruby" target="_blank">blog post</a> about it.</li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[.[ ] Method...Huh?]]></title>
    <link href="http://kylefdoherty.github.io/blog/2014/02/27/square-brackets-ruby-method/"/>
    <updated>2014-02-27T12:25:28-05:00</updated>
    <id>http://kylefdoherty.github.io/blog/2014/02/27/square-brackets-ruby-method</id>
    <content type="html"><![CDATA[<p>I came across the blog post <a href="http://sirupsen.com/what-I-wish-a-ruby-programmer-had-told-me-one-year-ago/" target="_blank">“What I Wish a Ruby Programmer Had Told Me One Year Ago”</a> and started reading through the author Simon’s code for the first iteration of his todo app to figure out what was going on.  One method he used was:
<code>ruby
def [](id)
  @list[id]
end
</code>
This had me pretty confused at first. Then when I looked at how he was running the code I saw he was calling this method like you would access an element in an array.
<code>ruby
list = TodoList.load("todo.td")
list[0].done = true
</code>
It turns out in Ruby you can use special characters to name methods including the array lookup syntax, square brackets.  In this way he names the method <code>[ ]</code> and passes it an <code>(id)</code>, which is then passed to the array <code>@list</code> to lookup that element in the <code>@list</code> array.  Essentially he’s creating a lookup on the instance of his class <code>TodoList</code>, so he can use <code>[ ]</code> to lookup specific todo items just like he would if here were accessing them in array, which technically he is&hellip;the @list array.  Pretty Cool!</p>

<p>Check out this Stackoverflow answer for some good examples of how to use the [ ] method, <a href="http://stackoverflow.com/questions/10018900/how-does-defining-square-bracket-method-in-ruby-work" target="_blank"><a href="http://stackoverflow.com/questions/10018900/how-does-defining-square-bracket-method-in-ruby-work">http://stackoverflow.com/questions/10018900/how-does-defining-square-bracket-method-in-ruby-work</a></a></p>

<p>Here is another great Stackoverflow answer about Ruby Method names, <a href="http://stackoverflow.com/questions/10542354/what-are-the-restrictions-for-method-names-in-ruby" target="_blank"><a href="http://stackoverflow.com/questions/10542354/what-are-the-restrictions-for-method-names-in-ruby">http://stackoverflow.com/questions/10542354/what-are-the-restrictions-for-method-names-in-ruby</a></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding a Feed Class &amp; CLI Interface to my Twitter Bot ]]></title>
    <link href="http://kylefdoherty.github.io/blog/2014/02/26/adding-a-feed-class-to-my-twitter-bot-and-cli-interface/"/>
    <updated>2014-02-26T06:47:41-05:00</updated>
    <id>http://kylefdoherty.github.io/blog/2014/02/26/adding-a-feed-class-to-my-twitter-bot-and-cli-interface</id>
    <content type="html"><![CDATA[<p>After reading the blog post <a href="http://sirupsen.com/what-I-wish-a-ruby-programmer-had-told-me-one-year-ago/" target="_blank">“What I Wish a Ruby Programmer Had Told Me One Year Ago”</a> and reading the code for his ToDo app I realized I should create a Feed class that has <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a> operations so I can list, add, edit, and delete my feeds.  It’s probably not the cleanest or most “ruby way" of doing it (if you have any suggestions please let me know) but it got the job done and I’ll refactor it to make it more rubish and/or turn it into a Sinatra app next.</p>

<p>```ruby</p>

<h1>class that stores feeds</h1>

<p>class Feed</p>

<pre><code>attr_accessor :file

def initialize(file = 'feeds.txt') # sets file to save feeds to, sets @feed array, and calls the list method 
    @file = file 
    @feeds = []

end 

def create # takes a feed from the user and adds it to the file 
    puts "Add feed"
    puts '&gt;&gt;'
    new_feed = gets.chomp
    File.open @file, 'a' do |f|
        f.puts new_feed
    end 
    puts "added the feed #{new_feed}"
end

def get_feeds #gets the feeds from the file and puts them in the @feeds array so they can be used by the .edit and .delete methods
    File.open(@file).readlines.each do |f|
        @feeds &lt;&lt; f.strip 
    end 
end 

def write_feeds #writes the @feeds array to the file so .edit and .delete can write the @feeds array they've changed to the file 
    File.open @file, 'w' do |f|
        @feeds.each {|feed| f.puts(feed)}
    end
end 

def edit(name) #takes a file name from the user and then checks if that exists in the @feeds array. 
    get_feeds  #If it does it gets the id and asks the user what they want to change the name to and then changes that index to the new name.
               #From here it calls the write_feeds method and writes the new array to the file 
    if @feeds.include?(name)
        index = @feeds.index(name)
        puts "What do you want to change #{name} to?"
        new_feed = gets.chomp
        @feeds[index] = new_feed
        write_feeds
    else 
        puts "no such feed"
    end 
    list
end 


def delete(name) #works almost the same as the .edit method but instead of changing the feed name it deletes it
    get_feeds

    if @feeds.include?(name) 
        index = @feeds.index(name)
        puts "Are you sure you want to delete #{name}?"
        puts "Enter 'yes' or 'no':"
        answer = gets.chomp.downcase
        if answer == "yes"
            @feeds.delete_if {|feed| feed == name}
            write_feeds
            puts "Feed #{name} has been deleted."
        else 
            puts "Ok I won't delete it then."
        end 
    else 
        puts "Sorry don't have that file."
    end 
end 

def list #if the feeds.txt file is empty it asks for feeds, if not it puts the feeds from the file 
    read_file = File.read @file
    if read_file.empty?
        puts "the file is empty please add some feeds"
        create
    else
        puts "here is the list of feeds from file #{@file}" 
        puts read_file
    end 
end 
</code></pre>

<p>end
```</p>

<p>After finishing this I decided I wanted to add some sort of command line interface so I could list out, add, edit, and delete the feeds from my terminal. I also added the -tweet command which runs the FeedParser class and begins tweeting out the feeds.  I realize there is an options parser library I could use for this but I wanted to design and build my own.</p>

<p>```ruby
require_relative &lsquo;feed&rsquo;
require_relative &lsquo;feed_parser&rsquo;</p>

<p>class CommandLineInterface #allows user to interact with feed.rb to list, add, edit, and delete</p>

<pre><code>def initialize 
    @feeds = Feed.new
    take_commands
end 

def take_commands
    puts "What do you want to do?  To see list of commands enter -commands"
    until false 
    response = gets.chomp.downcase
    parse_response(response)
    end 
end 

def parse_response(response)
    if response == "-commands"
        puts "-list   - list your feeds"
        puts "-add    - add a new feed"
        puts "-edit   - edit an existing feed"
        puts "-delete - delete an existing feed"
        puts "-tweet  - tweets out the feeds" 
        puts "-quit  - quit this program"

    else 
        case response 
        when "-list"
            @feeds.list
        when "-add"
            @feeds.add
        when "-edit"
            puts "feed name:"
            name = gets.chomp
            @feeds.edit(name)
        when "-delete"
            puts "feed name:"
            name = gets.chomp
            @feeds.delete(name)
        when "-tweet"
            parser = FeedParser.new(@feeds.get_feeds)
            parser.run

        when "-quit"
            exit 
        else 
            p 'not a valid command'
        end 
    end 
    take_commands
end 
</code></pre>

<p>end</p>

<p>cli = CommandLineInterface.new<br/>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recoding My RSS Twitter Bot]]></title>
    <link href="http://kylefdoherty.github.io/blog/2014/02/19/recoding-my-rss-twitter-bot/"/>
    <updated>2014-02-19T06:03:44-05:00</updated>
    <id>http://kylefdoherty.github.io/blog/2014/02/19/recoding-my-rss-twitter-bot</id>
    <content type="html"><![CDATA[<p>My last blog post about my RSS Twitter Bot made realize a lot of flaws with my bot, not only in the code I wrote but the choices I made about what to code.  This led me to re-code the entire bot, but I think the code is much cleaner now.</p>

<!-- more -->


<p>```ruby  Recoded RSS Twitter Bot
require &lsquo;rss&rsquo;
require &lsquo;open-uri&rsquo;
require &lsquo;twitter&rsquo;
require &lsquo;yaml&rsquo;</p>

<p>class FeedParser</p>

<pre><code>def initialize(*feeds)
    @feeds = feeds 
    @tweet = ""
    @pub_date = ""
    @tweet_length = Proc.new{ 
        if @tweet.length &gt; 140
            next 
        else 
            tweeter(@tweet)
            puts "tweeted"

            sleep(15)
        end 
    }

    config = YAML.load_file('config.yml')

    @client = Twitter::REST::Client.new({
        consumer_key: config['consumer_key'],
        consumer_secret: config['consumer_secret'],
        access_token: config['access_token'],
        access_token_secret: config['access_token_secret']
    })

end 

def run 
    feed_sorter
end 
</code></pre>

<h1>method that sorts feeds</h1>

<pre><code>def feed_sorter
    @feeds.each do |url|
        open(url) do |rss|
        feed = RSS::Parser.parse(rss)

            case 
            when feed.feed_type == "rss"
                rss_parser(feed)
            when feed.feed_type == "atom"
                atom_parser(feed) 
            end 
        end 
    end 
end 

def rss_parser(rss)
    rss.items.each do |item| 
        title = item.title
        link = item.link
        @tweet = "#{title} #{link}"
        @tweet_length.call 

    end 
end 


def atom_parser(atom)
    atom.items.each do |item| 
        title = item.title.content
        link = item.link.href
        @tweet = "#{title} #{link}"
        @tweet_length.call

    end 
end 

def tweeter(tweet)
    @client.update(tweet)
end 
</code></pre>

<p>end</p>

<p>parser = FeedParser.new(&lsquo;<a href="https://gdata.youtube.com/feeds/api/users/goaztecscom/uploads">https://gdata.youtube.com/feeds/api/users/goaztecscom/uploads</a>&rsquo;, &lsquo;<a href="http://www.utsandiego.com/rss/headlines/sports/sdsu-aztecs/">http://www.utsandiego.com/rss/headlines/sports/sdsu-aztecs/</a>&rsquo;)
parser.run
```</p>

<h2>I Switched to the RSS Module</h2>


<p>During and after writing the first post about my Twitter Bot I did more research into the Ruby RSS Module and found that it has <code>.feed_type</code> method that allows you to easily sort the types of feeds so you can use the correct methods to parse them.  Sorting the feeds this way is infinitely better than the weird/incorrect way I was doing it before albeit it was good practice with hashes.</p>

<p>```ruby Sorting Feeds with the RSS Module
@feeds.each do |url|</p>

<pre><code>open(url) do |rss|
feed = RSS::Parser.parse(rss)

    case 
    when feed.feed_type == "rss"
        rss_parser(feed)
    when feed.feed_type == "atom"
        atom_parser(feed) 
    end 
end 
</code></pre>

<p>end
```</p>

<h2>I Finally Used a Proc in my Code</h2>


<p>I remember learning about Procs and Lamdas on Codecademy and thinking they were pretty cool&hellip;ok really cool.  Since that time I haven’t used them in my code, accept when trying to code FizzBuzz in as many different ways as possible, which sort of makes sense since everything I’m doing is super simple, but still&hellip;I want to use a some damn Procs.</p>

<p>Finally, I found a reason.  When re-coding my bot I decided there was no reason to try and adjust the length of the feed titles because eventually my bot will hopefully use a URL shortener, meaning 99.99% of the time the titles will never make the tweet go over 140 characters.  Still I needed an easy way to keep <code>@tweets</code> that are over 140 characters from being sent to the <code>.tweeter</code> method and causing an error.  Obviously, I could stick an if/else statement in a method and call it from the &lt;.rss> and &lt;.atom> methods, but using a Proc sounded way more fun :).</p>

<p>```ruby Using a Proc
@tweet_length = Proc.new{
if @tweet.length > 140</p>

<pre><code>    next 
else 
    tweeter(@tweet)
    puts "tweeted"
    sleep(15)
end 
</code></pre>

<p>}
```</p>

<h2>Next Steps</h2>


<ol>
  <li>Check for new articles, videos, etc. in the feeds and only tweet the new ones</li>
  <li>Learn Sinatra and turn this into a Sinatra App</li>
  <li>Add a url shortner like bit.ly or roll my own</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Notes - Working with Files]]></title>
    <link href="http://kylefdoherty.github.io/blog/2014/02/17/ruby-notes-working-with-files/"/>
    <updated>2014-02-17T16:56:05-05:00</updated>
    <id>http://kylefdoherty.github.io/blog/2014/02/17/ruby-notes-working-with-files</id>
    <content type="html"><![CDATA[<p>My next “Ruby Notes” post was going to be on arrays but in my last couple of mini projects, <a href="https://github.com/kylefdoherty/ruby-quiz-solutions/tree/master/text_munger_76" target="_blank">Text Munger problem on RubyQuiz</a>, and building an <a href="https://github.com/kylefdoherty/image-editor" target="_blank">image editor command line app</a>, I had to work a lot with files and directories and realized I didn’t have a great handle on them.  To remedy this I did what I always do, a bunch of reading, practice problems, and put it all down in my notebook.  There still is a lot for me to learn but I think this lays a good foundation for understanding and working with files in Ruby.</p>

<!-- more -->


<h2>IO Class</h2>


<p>The IO class is the parent class for the File class and thus is where it gets a ton of its methods such as readlines and readline.  IO stands for input/output, specifically input/output streams which are sequences of data that allow you to do things like play sound on your speakers and print output to a screen.  The IO class allows you to initialize streams and do things with them.</p>

<h2>Standard Output, Input, and Error</h2>


<p>STDOUT, STDIN, and STDERR are ruby constants that are IO objects pointing to your programs output, input, and error streams.  You can access these streams through the terminal without opening any files.</p>

<p>When you do something like call puts, output is sent to the IO object that STDOUT points to.  Conversely when you call get, input is captured by the IO object that STDIN points to.</p>

<p><strong>Further Reading:</strong> <a href="https://rubymonk.com/learning/books/1-ruby-primer/chapters/42-introduction-to-i-o/lessons/89-streams" target="_blank"><a href="https://rubymonk.com/learning/books/1-ruby-primer/chapters/42-introduction-to-i-o/lessons/89-streams">https://rubymonk.com/learning/books/1-ruby-primer/chapters/42-introduction-to-i-o/lessons/89-streams</a></a></p>

<h2>File Class</h2>


<p>According to the <a href="http://ruby-doc.org/core-1.9.3/File.html" target="_blank">ruby doc</a>, a File is an abstraction of any file object accessible by the program and is closely associated with the class IO (it’s a subclass of IO).</p>

<p>You use the File class to create files, read them, and write to them.  There are various modes that can be given to the File class telling it what its behaviour is i.e. can read it, can write to it, can do both, etc.  These modes are inherited from the IO class and are listed below.</p>

<p></style></p>

<h3>Modes</h3>


<table style="width:700px">
    <tr>
      <th>Mode</th>
      <th>Meaning</th>      
    </tr>
    <tr>
      <td>"r"</td>
      <td>Read-only, starts at beginning of file  (default mode).</td>      
     </tr>
    <tr>
      <td>"r+"</td>
      <td>Read-write, starts at beginning of file.</td>     
    </tr>
    <tr>
      <td>"w"</td>
      <td>Write-only, truncates existing file to zero length or creates a new file for writing.</td>        
    </tr>
    <tr>
      <td>"w+"</td>
      <td>Read-write, truncates existing file to zero length or creates a new file for reading and writing.</td>        
    </tr>
    <tr>
      <td>"a"</td>
      <td>Write-only, starts at end of file if file exists, otherwise creates a new file for writing.</td>      
    </tr>
    <tr>
      <td>"a+"</td>
      <td>Read-write, starts at end of file if file exists, otherwise creates a new file for reading and writing.</td>      
    </tr>
    <tr>
      <td>"b"</td>
      <td>Binary file mode (may appear with any of the key letters listed above). Suppresses EOL <-> CRLF conversion on Windows. And sets external encoding to ASCII-8BIT unless explicitly specified.</td>     
    </tr>
    <tr>
      <td>"t"</td>
      <td>Text file mode (may appear with any of the key letters listed above except "b").</td>     
    </tr>
</table>


<br>




<h2>Writing to a File</h2>


<p>```ruby Writing to a File
file = File.open(“text.txt”, “w”)
file.puts “Hello from #{$0}”
file.close</p>

<h1>=> writes “Hello from io.rb” to the file text.txt</h1>

<p>```
On the first line I’m calling the <code>.open</code> method on the File class and passing it the file text.txt and the mode I want the file to use, “w”.  Next I’m using the <code>.puts</code> method to write to the file and passing it the text I want it to write to the file.  Note, that If we didn’t have a file text.txt in our directory, this script would have created it.</p>

<h3>Using Block Notation</h3>


<p><code>ruby Writing to a File with Block Notation
File.open(“text.txt”,”w”){|file| file.puts”Hola from $0”}
</code></p>

<p>Note that when passing a block to File you don’t have to close it because when the block is exited it closes the File for you.</p>

<h2>Reading a File</h2>


<p><code>ruby Reading from a File
file = File.open(“lib/I_have_a_dream.txt”)
contents = file.read
puts contents
file.close
</code>
This is pretty simple.  We’re opening the file we want to read with the <code>.open</code> method and storing it in the file variable.  Then we call the <code>.read</code> method on file and store it in contents and then puts the contents.
<code>.read</code> starts reading from the place the last <code>.read</code> operation stopped. Here we’ve read the entire file and thus if below <code>puts contents</code> we tried to read the file again there would be nothing to read because we&rsquo;re at the end of the file.</p>

<h3>Reading a File Block Notation</h3>


<p><code>ruby Reading from a File Block Notation
contents = File.open(“lib/I_have_a_dream.txt”, “r”){|file| file.read}
puts contents
</code></p>

<h2>Closing Files</h2>


<p>If you open a file make sure you close it, unless you’re passing File a block and then the block will close the file when it ends.</p>

<p>The reason you need to close files is it forces a “flush”, which means it pushes the data-to-be-written to where you want it to be.  This frees up memory for the rest of your program and ensures the file is available for other processes to access.</p>

<p><strong>Further Reading:</strong> <a href="http://ruby.bastardsbook.com/chapters/io/" target="_blank"><a href="http://ruby.bastardsbook.com/chapters/io/">http://ruby.bastardsbook.com/chapters/io/</a></a></p>

<h2>More File Methods</h2>


<p>We’ve already seen some file methods like .open and .close but here are some more useful ones. Checkout the ruby doc for File and IO for the rest of them.</p>

<h3>.readlines & .readline</h3>


<p>These two methods can be very handy when you want to read one line at a time.  This would be useful for instance if you are reading a comma delimited file.</p>

<h3>.readlines</h3>


<p> &ndash; takes in all the content of the file and stores each line as an element of an array.  From here you can iterate over each line using each.</p>

<p><code>ruby Using Readlines
File.open(read_file).readlines.each do |line|
puts line
end
</code></p>

<h3>.readline</h3>


<p> &ndash; is a bit different in it only reads one line at a time and thus you need to keep advancing it forward in the file, which can be done with a <code>while</code> or <code>until</code> method.</p>

<p><code>ruby Using Readline
file = File.open("lib/blood_sweat_tears.txt")
until file.eof?
   line = file.readline
   puts line
end
file.close
</code></p>

<p>The reason you would want to <code>.readline</code> vs <code>.readlines</code> is because <code>.readlines</code> loads the entire contents of the file into memory.  For a small script working with small files this isn’t a problem but if you are using large files and/or have multiple users this is bad.</p>

<h3>.exists?</h3>


<p> &ndash; checks for the existence of the file.</p>

<p>```ruby
if File.exists?(“file_name”)</p>

<pre><code>#do something 
</code></pre>

<p>end
```</p>

<h3>.absolute_path</h3>


<p> &ndash; gets the absolute path for the.</p>

<p>``` ruby
puts File.absolute_path(&ldquo;lib/blood_sweat_tears.txt&rdquo;)</p>

<h1>=> “/Users/kyledoherty/Dropbox/Ruby/learn_to_program/working_w_files/lib/blood_sweat_tears.txt”</h1>

<p>```</p>

<h3>.basename</h3>


<p> &ndash; gives you just the filename.</p>

<p>``` ruby
puts File.basename(“/Users/kyledoherty/Dropbox/Ruby/learn_to_program/working_w_files/lib/blood_sweat_tears.txt”)</p>

<h1>=> “blood_sweat_tears.txt’</h1>

<p>```</p>

<h3>.directory?</h3>


<p> &ndash; returns true if the string passed to it is a directory.</p>

<p>``` ruby
Dir.open(Dir.pwd).each do |filename|</p>

<pre><code>next if File.directory? filename 
</code></pre>

<p>end
```</p>

<h2>Dir Class</h2>


<p>The Directory class allows you to work with driectories as you’d expect.  Most of the methods you can use on the directory class are the same as the commands you use in the console.</p>

<h2>Some Dir Methods</h2>




<h3>.pwd</h3>


<p> &ndash; tells you what directory you’re in.</p>

<p>```ruby
puts Dir.pwd</p>

<h1>=> &ldquo;/Users/kyledoherty/Dropbox/Ruby/image_edit&rdquo;</h1>

<p>```</p>

<h3>.chdir</h3>


<p> &ndash;  allows you to change to a new directory.</p>

<p>```ruby
Dir.chdir(“"/Users/kyledoherty/Dropbox/Ruby/rubyquiz”</p>

<h1>=> 0</h1>

<p>```</p>

<h3>.mkdir</h3>


<p> &ndash; makes a new directory named the string it is passed.</p>

<p>```ruby
Dir.mkdir(“stuff”)</p>

<h1>=> 0</h1>

<p>```</p>

<h3>.rmdir</h3>


<p> &ndash; removes an empty directory but throws an error if it contains files.  To remove a directory with files you must use the FileUtils module.</p>

<p>```ruby
Dir.rmdir(“stuff”)</p>

<h1>=> 0</h1>

<p>```</p>

<h2>Accessing Directory Content</h2>


<p>There are two ways to grab content from directories, using .entries and .glob.</p>

<h3>.entries</h3>


<p> &ndash;  returns an array with every single entry inside the diretory including “.” and hidden files.</p>

<p>```ruby
Dir.entries(“../rubyquiz”)</p>

<h1>=> [&ldquo;.&rdquo;, &ldquo;..&rdquo;, &ldquo;.DS_Store&rdquo;, &ldquo;.git&rdquo;, &ldquo;README&rdquo;, &ldquo;text_munger_76&rdquo;]</h1>

<p>```</p>

<h3>.glob</h3>


<p> &ndash; can be passed a directory name or pattern such as <code>*.txt</code> and returns an array of just the visible files</p>

<p>```ruby
Dir.entries(“*”)</p>

<h1>=> [&ldquo;README&rdquo;, &ldquo;text_munger_76&rdquo;]</h1>

<p>```
Gives us the files in the current directory.</p>

<p>```ruby
Dir.entries(“<em>*/</em>.txt”)</p>

<h1>=> [&ldquo;text_munger_76/lib/blood_sweat_tears.txt&rdquo;, &ldquo;text_munger_76/lib/gettysburg_address.txt&rdquo;, &ldquo;text_munger_76/lib/I_have_a_dream.txt&rdquo;, &ldquo;text_munger_76/lib/pearl_harbor_address.txt&rdquo;, &ldquo;text_munger_76/lib/strength_and_decency.txt&rdquo;]</h1>

<p>```
Here we use <code><em>*/</em>.txt</code> to search the current directory and all it’s sub directories for any .txt files using a recursive search and passing it the pattern .txt.</p>

<h2>FileUtils Module</h2>


<p>I’m not going to go into FileUtils too much but it allows more control over files and mimics a lot of the command line commands and flags you can use such as <code>rm -rf</code> for removing directories that contain files.</p>

<h2>Some Methods</h2>




<h3>.mkdir</h3>


<p> &ndash; makes a directory</p>

<h3>.touch</h3>


<p> &ndash; makes a file</p>

<h3>.rm_rf</h3>


<p> &ndash; removes a directory whether it contains other files and directories or not</p>

<p>```ruby
if File.exists?(“file_name”)
FileUtils.rm_rf(“file_name”)
end</p>

<p>```</p>

<p>Note: you need to require FileUtils in your files with <code>require ‘fileutils’</code></p>
]]></content>
  </entry>
  
</feed>
